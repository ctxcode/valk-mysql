
use valk:mem

extend Connection {
    // binds: Array[<MySQLBind>] (.{})
    bind_data: ?*[<MySQLBind>] (null)
    bind_length: uint (0)
    bind_size: uint (0)
    str_binds: Array[String] (.{})

    fn clear_binds() {
        this.str_binds.clear()
        this.bind_length = 0
    }
    fn close_binds() {
        if this.bind_size > 0 : mem:free(this.bind_data)
    }

    + fn bind(value: $T) {

        #if is_nullable_type(T)
        if !isset(value) {
            this.bind_null()
            return
        }
        #end

        #if is_integer_type(T)
        this.bind_int(value)
        #elif is_float_type(T)
        this.bind_double(value)
        #elif is_bool_type(T)
        this.bind_bool(value)
        #elif is_type_of_class(T, String)
        this.bind_string(value)
        #elif is_structural_type(T)
        #loop object value as prop
        this.bind(prop.value)
        #end
        #else
        #print_type(T)
        #error "Cannot bind this value type to the query"
        #end
    }

    + fn bind_null() {
    }

    fn get_bind() MySQLBind {
        // let len = thins.binds.length++
        // let data = this.binds.increase_size(len + 1)
        // return this.binds.get(len)
        // return @ref(data.@cast(*[<MySQLBind>])[0])

        let len = ++this.bind_length
        if len > this.bind_size {
            let old = this.bind_data
            let old_size = size_of(<MySQLBind>) * this.bind_size
            this.bind_size += 10
            let new_size = size_of(<MySQLBind>) * this.bind_size
            this.bind_data = mem:alloc(new_size).@cast(*[<MySQLBind>])
            if isset(old) {
                mem:copy(old, this.bind_data, old_size)
                mem:free(old)
            }
        }
        return @ref(this.bind_data[len - 1])
    }
}
