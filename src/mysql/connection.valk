
use valk:time
use valk:core

global inited : bool (false)

class Connection {
    m: MySQL
    host: ?String
    user: String
    password: String
    db: String
    port: u32
    socket: ?String
    flag: u64
    closed: bool (false)

    + static fn new(host: ?String, user: String, password: String, db: String, port: u32, socket_path: ?String (null)) Connection {

        if !inited {
            core:race_lock()
            mysql_library_init(0, null, null) 
            inited = true
            core:race_unlock()
        }
        let m = mysql_init(null)

        return Connection {
            m: m
            host: host
            user: user
            password: password
            db: db
            port: port
            socket: socket_path
            flag: 0
        }
    }

    + fn connect() !error !closed {
        if this.closed : throw closed

        let host = this.host
        let socket = this.socket
        let h : ?cstring = null
        let sock : ?cstring = null
        if isset(host) : h = host.data_cstring
        if isset(socket) : sock = socket.data_cstring

        while true {
            let res = mysql_real_connect_nonblocking(this.m, h, this.user.data_cstring, this.password.data_cstring, this.db.data_cstring, this.port, sock, this.flag)
            match res {
                ASYNC.COMPLETE => break
                ASYNC.NOT_READY => {
                    time:sleep_ms(1)
                    continue
                }
                ASYNC.ERROR => {
                    let msg = mysql_error(this.m)
                    throw error, msg.to(String)
                }
                default => throw error, "Unknown error"
            }
        }
    }

    + fn query(statement: String) Result !error {
        while true {
            let res = mysql_real_query_nonblocking(this.m, statement.data_cstring, statement.length)
            match res {
                ASYNC.COMPLETE => break
                ASYNC.NOT_READY => {
                    time:sleep_ns(1000)
                    continue
                }
                ASYNC.ERROR => {
                    let msg = mysql_error(this.m)
                    throw error, msg.to(String)
                }
                default => throw error, "Unknown error"
            }
        }
        let r = mysql_use_result(this.m)
        if !isset(r) : throw error
        return Result {
            con: this
            r: r
        }
    }

    fn close() {
        this.close_binds()
        if this.closed : return
        this.closed = true
        mysql_close(this.m)
        // #if defined(MYSQL_DEBUG)
        print("> Connection closed\n")
        // #end
    }

    fn gc_free() {
        print("> Closing\n")
        this.close()
    }
}
